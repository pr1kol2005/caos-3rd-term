# Float
В этой задаче вы станете чем-то ближе к молодому Петру Первому. У вас тоже появится свой игрушечный флот. 

Вам необходимо реализовать абстрактное число с плавающей точкой с произвольной битностью мантиссы и экспоненты.

## Содержание

1. [Сдача пунктов](#submission)
2. [Пункты](#tasks)
    1. [Умножение](#stage1)
        1. [Как реализовать умножение?](#stage1-1)
        2. [Требуемые к реализации функции](#stage1-2)
    2. [Переход к ближайшему большему / меньшему](#stage2)
        1. [Требуемые к реализации функции](#stage2-2)
    3. [Сложение / вычитание чисел](#stage3)
        1. [Как реализовать сложение?](#stage3-1)
        2. [Требуемые к реализации функции](#stage3-2)
    4. [Деление](#stage4)
        1. [Как реализовать деление?](#stage4-1)
        2. [Требуемые к реализации функции](#stage4-2)
    5. [Перевод в строку / из строки](#stage5)
        1. [Как реализовать перевод числа в строку?](#stage5-1)
        2. [Как реализовать перевод строки в число?](#stage5-2)
        3. [Требуемые к реализации функции](#stage5-3)
3. [Нормализация результата](#normalize)
4. [Доступный инструментарий](#instruments)
    1. [DynamicLongInt](#DynamicLongInt)
        1. [Создание экземпляра](#DynamicLongInt-1)
        2. [Использование](#DynamicLongInt-2)
    2. [DynNum](#DynNum)
        1. [Создание экземпляра](#DynNum-1)
        2. [Использование](#DynNum-2)
5. [Полезные ссылки](#links)

Ваша реализация должна работать так же, как ваш системный `float` и `double`. Самая большая сложность - округлять результат каждой операции в правильную сторону. Вам нужно будет реализовать округление *"to nearest, tie to even"* - округлять в ближайшую сторону, отдавая приоритет числу с чётным младшим битом.

**Обратите внимание:** Битность мантиссы может превышать 64 (и даже 128) бит. Вам понадобится использовать класс `DynamicLongInt` ([solution/LongInt.hpp]()), или реализовать свою обёртку над длинными типами данных. Про то, как пользоваться `DynamicLongInt`, сказано в [соответствующей главе](#DynamicLongInt). Вы можете писать своё решение на Си, но тогда вам придётся реализовать подобную структуру самостоятельно.

# <a id="submission" name="submission"><a href="#submission">1.</a></a> Сдача пунктов:

Пункты предполагается решать последовательно, но мы не успели переехать на новую версию `manytask` перед запуском курса, и разбить задание на пункты по-человечески в этом семестре уже не получится.

Каждый пункт пришлось оформить как отдельное задание, поэтому алгоритм сдачи выглядит так:

$1$: Склонировать репозиторий задания `float-mul`, решить первый пункт, сдать в систему и получить полный балл.

$2$: Склонировать репозиторий задания `float-next-prev`, перенести в него ваш код из `float-mul`, решить второй пункт, сдать в систему и получить полный балл.

...

$N$: Склонировать репозиторий задания $N$, перенести в него ваш код из $N-1$, решить $N$-ный пункт, сдать в систему и получить полный балл.

**Note**: Следующий пункт нельзя сдать без предыдущего.

# <a id="tasks" name="tasks"><a href="#tasks">2.</a></a> Пункты:

| №     | Задание                                                  | Команда для тестирования | Баллы |
|-------|----------------------------------------------------------|--------------------------|-------|
| **1** | [Умножение](#stage1)                                     | `make test-stage-1`      | 100   |
| **2** | [Переход к ближайшему большему / меньшему](#stage2)      | `make test-stage-2`      | 100   |
| **3** | [Сложение / вычитание чисел](#stage3)                    | `make test-stage-3`      | 150   |
| **4** | [Деление](#stage4)                                       | `make test-stage-4`      | 150   |
| **5** | [Перевод в строку / из строки](#stage5)                  | `make test-stage-5`      | 250   |

## <a id="stage1" name="stage1"><a href="#stage1">2.1</a></a> Умножение

### <a id="stage1-1" name="stage1-1"><a href="#stage1-1">2.1.1.</a></a> Как реализовать умножение?

- Число с плавающей точкой (в нормализованном виде) представлено как $-1^\text{sign} \cdot 2^{\left(\text{exponent}-2^{\text{exponent\_bits - 1}} + 1\right)} \cdot (1 + \frac{\text{mantissa}}{2^{\text{mantissa\_bits}}})$;

- При умножении двух таких чисел показатели степеней в левой части сложатся;

- Остаётся умножить правые части: $(1 + \frac{\text{mantissa\_a}}{2^{\text{mantissa\_bits}}}) \cdot (1 + \frac{\text{mantissa\_b}}{2^{\text{mantissa\_bits}}})$;
- Если домножить обе скобки на $2^{\text{mantissa\_bits}}$, получится целочисленное произведение $(2^{\text{mantissa\_bits}} + \text{mantissa\_a}) \cdot (2^{\text{mantissa\_bits}} + \text{mantissa\_b})$. Результат будет больше правильного в $2^{2 \cdot \text{mantissa\_bits}}$ раз. Это можно скомпенсировать, отняв $2 \cdot \text{mantissa\_bits}$ от итоговой экспоненты;
- [Нормализуйте](#normalize) результат, и не забудьте округлить его в правильную сторону.

**Самостоятельная задача:** Обобщить алгоритм для учёта [денормализованных](https://en.wikipedia.org/wiki/Subnormal_number) аргументов.

### <a id="stage1-2" name="stage1-2"><a href="#stage1-2">2.1.2.</a></a> Требуемые к реализации функции:

- `int float_init(Float* self, int exponent_bits, int mantissa_bits)`:
  - **Конструктор:** инициализирует `Float` по адресу `self`;
  - Фиксирует размер экспоненты в `exponent_bits` бит;
  - Фиксирует размер мантиссы в `mantissa_bits` бит;
  - Тестируется набором тестов `construct`;
  - Возвращает 0 при успешной инициализации, иначе - отрицательное число.


- `void float_destroy(Float* self)`:
  - **Деструктор:** освобождает всю память, используемую этим `Float`;
  - Тестируется набором тестов `construct`.

**Функции ниже вызываются только между `float_init` и `float_destroy`.**

- `void float_set_sign(Float* self, bool sign)`:
  - **Устанавливает бит знака**;
  - Тестируется набором тестов `construct`.
  

- `void float_set_mantissa(Float* self, const void* mantissa)`:
  - **Устанавливает мантиссу**;
  - `mantissa` - указатель на `n`-байтное число, где `n = (mantissa_bits + 7) / 8`;
  - Число закодировано в Little Endian (первый байт младший, последний - старший);
  - Тестируется набором тестов `construct`.


- `void float_set_exponent(Float* self, const void* exponent)`:
  - **Устанавливает экспоненту**;
  - `exponent` - указатель на `n`-байтное число, где `n = (exponent_bits + 7) / 8`;
  - Число закодировано в Little Endian (первый байт младший, последний - старший);
  - Тестируется набором тестов `construct`.


- `bool float_get_sign(const Float* self)`:
  - **Возвращает бит знака**;
  - Тестируется набором тестов `construct`.


- `void float_get_mantissa(const Float* self, void* target)`:
  - **Возвращает мантиссу** в буфере по адресу `target`;
  - Размер буфера `target` равен `(mantissa_bits + 7) / 8`;
  - Мантисса должна быть закодирована в Little Endian;
  - Тестируется набором тестов `construct`.


- `void float_get_exponent(const Float* self, void* target)`:
  - **Возвращает экспоненту** в буфере по адресу `target`;
  - Размер буфера `target` равен `(exponent_bits + 7) / 8`;
  - Экспонента должна быть закодирована в Little Endian;
  - Тестируется набором тестов `construct`.


- `void float_mul(Float* result, const Float* a, const Float* b)`:
  - **Умножает числа `a` и `b`** и записывает результат в `result`;
  - `a`, `b` и `result` инициализированы с одинаковым размером мантиссы и экспоненты;
  - Тестируется набором тестов `mul`.

## <a id="stage2" name="stage2"><a href="#stage2">2.2.</a></a> Переход к ближайшему большему / меньшему

### <a id="stage2-2" name="stage2-2"><a href="#stage2-2">2.2.1.</a></a> Требуемые к реализации функции:

- `void float_next(Float* self)`:
  - Изменяет `self` на ближайшее большее число с плавающей точкой;
  - Работает аналогично `std::nextafter(self, HUGE_VALF)`;
  - Должен изменять `-inf` в минимальное число, не равное бесконечности;
  - Должен изменять `-0` в `+0`;
  - Должен изменять максимальное небесконечное число в `+inf`;
  - Не изменяет `+inf` и `nan`;
  - Тестируется набором тестов `prev_next`.


- `void float_prev(Float* self)`:
  - Изменяет `self` на ближайшее меньшее число с плавающей точкой;
  - Работает аналогично `std::nextafter(self, -HUGE_VALF)`;
  - Должен изменять `inf` в максимальное число, не равное бесконечности;
  - Должен изменять `+0` в `-0`;
  - Должен изменять минимальное небесконечное число в `-inf`;
  - Не изменяет `-inf` и `nan`;
  - Тестируется набором тестов `prev_next`.

## <a id="stage3" name="stage3"><a href="#stage3">2.3.</a></a> Сложение / вычитание чисел

### <a id="stage3-1" name="stage3-1"><a href="#stage3-1">2.2.1.</a></a> Как реализовать сложение?

- Чтобы сложить два числа с плавающей точкой, вам может потребоваться приравнять их экспоненты, поделив мантиссу левой или правой части на какую-то степень двойки. В десятичной записи это выглядело бы так:

$$
1.2 * 10^3 + 3.4 * 10^1 = \\\\
1.2 * 10^3 + 0.034 * 10^3 = \\\\
(1.2 + 0.034) * 10^3 = 1.234 * 10^3 \\\\
$$

- Не забудьте, что к мантиссе неявно прибавляется единица (если это не [денормализованное](https://en.wikipedia.org/wiki/Subnormal_number) число);
- Когда экспоненты левой и правой части оказываются равны, их мантиссы можно целочисленно сложить (или вычесть, в зависимости от операции и от знака операндов);
- [Нормализуйте](#normalize) результат;
- Не забудьте, что вам нужно округлять результат в правильную сторону (*to nearest, tie to even*). Самый простой способ это сделать - заранее сдвинуть мантиссы на много бит влево, чтобы при выравнивании экспонент не потерять важные младшие биты мантиссы числа с меньшей экспонентой.

**Самостоятельная задача**: На сколько бит достаточно сдвинуть влево мантиссы перед выравниванием экспонент?

Ответ на эту задачу также подскажет вам, какой минимальной длины должен быть тип данных, хранящий $n$-битную мантиссу.

### <a id="stage3-2" name="stage3-2"><a href="#stage3-2">2.3.2.</a></a> Требуемые к реализации функции:

- `float_add(Float* result, const Float* a, const Float* b)`:
  - **Складывает числа `a` и `b`** и записывает результат в `result`;
  - `a`, `b` и `result` инициализированы с одинаковым размером мантиссы и экспоненты;
  - Тестируется набором тестов `add`.


- `float_sub(Float* result, const Float* a, const Float* b)`;
  - **Вычитает `b` из `a`** и записывает результат в `result`;
  - `a`, `b` и `result` инициализированы с одинаковым размером мантиссы и экспоненты;
  - Тестируется набором тестов `add`.

## <a id="stage4" name="stage4"><a href="#stage4">2.4.</a></a> Деление

### <a id="stage4-1" name="stage4-1"><a href="#stage4-1">2.4.1.</a></a> Как можно реализовать деление?

- Число с плавающей точкой (в нормализованном виде) представлено как $-1^\text{sign} \cdot 2^{\left(\text{exponent}-2^{\text{exponent\_bits - 1}} + 1\right)} \cdot (1 + \frac{\text{mantissa}}{2^{\text{mantissa\_bits}}})$;

- При делении двух таких чисел показатели степеней в левой части выражения вычитаются;

- Остаётся частное правых частей $\frac{1 + \frac{\text{mantissa\_a}}{2^{\text{mantissa\_bits}}}}{1 + \frac{\text{mantissa\_b}}{2^{\text{mantissa\_bits}}}}$. Поскольку числитель и знаменатель лежат в пределах $[1, 2)$, а нас интересуют не больше чем $\text{mantissa\_bits} + 1$ бит результата, можно домножить дробь на $2^{\text{mantissa\_bits} + 1}$ и поделить целочисленно. Остаток от деления подскажет, в какую сторону округлить результат;

- Результат нужно привести к виду $2^{\text{mantissa\_bits} + 1} \cdot (1 + \text{mantissa\_result})$. Это будет ваша итоговая правая часть. Для этого может потребоваться домножить мантиссу на какую-то степень двойки и скорректировать значение экспоненты;

- [Нормализуйте](#normalize) результат, и не забудьте округлить его в правильную сторону.

**Note**: Целочисленное деление длинных типов вам придётся реализовать самостоятельно.

**Note**: Не забудьте про обработку крайних случаев: `NaN`, и `+/-Inf` в аргументах, деление на ноль, и т.д.

**Самостоятельная задача**: Обобщите алгоритм для поддержки [денормализованных](https://en.wikipedia.org/wiki/Subnormal_number) аргументов.

### <a id="stage4-2" name="stage4-2"><a href="#stage4-2">2.4.2.</a></a> Требуемые к реализации функции:

- `float_div(Float* result, const Float* a, const Float* b)`:
  - **Делит `a` на `b`** и записывает результат в `result`;
  - `a`, `b` и `result` инициализированы с одинаковым размером мантиссы и экспоненты;
  - Тестируется набором тестов `div`.

## <a id="stage5" name="stage5"><a href="#stage5">2.5.</a></a> Перевод в строку / из строки

### <a id="stage5-1" name="stage5-1"><a href="#stage5-1">2.5.1.</a></a> Как реализовать перевод числа в строку:

Число с плавающей точкой (в нормализованном виде) представлено как $-1^\text{sign} \cdot 2^{\left(\text{exponent}-2^{\text{exponent\_bits - 1}} + 1\right)} \cdot (1 + \frac{\text{mantissa}}{2^{\text{mantissa\_bits}}})$ Для перевода в строку можно воспользоваться библиотекой десятичной длинной арифметики и выполнить следующий алгоритм:

1. Результат `:=` 0 в длинной арифметике;
2. Если число нормализованное, прибавить к результату 1;
3. Прибавить к результату значение мантиссы, умноженное на $2^{-\text{mantissa\_bits}}$;
4. Умножить результат на $2^{\left(\text{exponent}-2^{\text{exponent\_bits - 1}} + 1\right)}$ (или на $2^{\left(-2^{\text{exponent\_bits - 1}} + 2\right)}$, если число денормализованное);
5. Если $\text{sign} = 1$, умножить результат на $-1$.

**Note**: В классе `DynNum` реализовано бинарное возведение в степени (метод `binpow(int power)`). Рекомендуется использовать его при умножении на $2^x$.

**Note**: `binpow(int power)` принимает только положительный аргумент. Для умножения на $2^{-x}$ умножайте на $0.5^{x}$.

### <a id="stage5-2" name="stage5-2"><a href="#stage5-2">2.5.2.</a></a> Как реализовать перевод строки в число:

Если вы уже умеете переводить число в строку (и сравнивать друг с другом строки, что умеет класс `DynNum`), вы можете применить два бинарных поиска:

1. Найти правильную экспоненту (такую, что с нулевой мантиссой вы оказываетесь нестрого ниже правильного результата);
2. Найти правильную мантиссу.

Не забудьте, что вам нужно округлять результат в правильную сторону! *(to nearest, tie to even)*.

**Вопрос**: Какая сложность будет у такого алгоритма?

### <a id="stage5-3" name="stage5-3"><a href="#stage5-3">2.5.3.</a></a> Требуемые к реализации функции:

- `int float_string(const Float* self, char* string, int n)`:
  - Записывает строковое представление `self` (не более `n` байт) в строку по адресу `string`;
  - Возвращает длину строкового представления (может быть больше `n`);
  - `string` может быть `NULL`, а `n` - `0`, тогда всё равно требуется вернуть правильную длину;
  - При ошибке возвращает отрицательное число;
  - Тестируется набором тестов `string`.


- `void float_parse(Float* self, const char* string)`:
  - Записывает в `self` число, наиболее близкое к записанному в `string`;
  - Тестируется набором тестов `string`.

# <a id="normalize" name="normalize"><a href="#normalize">3.</a></a> Нормализация результата:

- После каждой операции вам, возможно, придётся нормализовать результат: результат поделить или домножить мантиссу результата на какую-то степень двойки, чтобы у неё стала правильная длина ($\text{mantissa\_bits} + 1$ бит). По пути нужно будет увеличивать или уменьшать экспоненту соответственно;
- Если при нормализации ваша экспонента стала нулевой (или отрицательной), ваш результат будет [денормализованным](https://en.wikipedia.org/wiki/Subnormal_number). Нужно оставить экспоненту нулевой и вернуть мантиссу как она есть, не удаляя старшую единицу;
- Если у вас получилось нормализованное число (экспонента оказалась больше нуля), старшую единицу нужно будет удалить. Она хранится неявно.

# <a id="instruments" name="instruments"><a href="#instruments">4.</a></a> Доступный инструментарий

Если вы используете C++ для решения задачи, вы можете использовать готовые структуры длинных типов и длинной десятичной арифметики.

## <a id="DynamicLongInt" name="DynamicLongInt"><a href="#DynamicLongInt">4.1.</a></a> `DynamicLongInt`

Класс принимает два шаблонных параметра:
- `bool signed` - знаковое или беззнаковое нужно хранить число;
- `typename Digit` - какой базовый тип использовать для цифр этого длинного типа.

Быстрее всего будет работать, если использовать `Digit = uint64_t`.

### <a id="DynamicLongInt-1" name="DynamicLongInt-1"><a href="#DynamicLongInt-1">4.1.1.</a></a> Создание экземпляра

  - `DynamicLongInt<...>::with_digits(int digits)` - создаёт экземпляр `DynamicLongInt<...>` длины `digits` цифр;

  - `DynamicLongInt<...>::as(const DynamicLongInt& other)` - создаёт экземпляр `DynamicLongInt<...>` с такой же размерностью, как и `other`;

  - `DynamicLongInt<...>::DynamicLongInt(const DynamicLongInt& copy)` - конструктор копирования;

  - `DynamicLongInt<...>::DynamicLongInt(DynamicLongInt& move)` - конструктор перемещения.

Сконструировать `DynamicLongInt`, не задав явно его размера, невозможно.

**Пример:** `DynamicLongInt<false, uint64_t>::with_digits(8)` даст своеобразный `uint512_t`.

### <a id="DynamicLongInt-2" name="DynamicLongInt-2"><a href="#DynamicLongInt-2">4.1.2.</a></a> Использование

- К `DynamicLongInt` можно присвоить любой целочисленный тип. Его размер от этого не изменится;

- `DynamicLongInt` работает как обычный целочисленный тип. Его можно:
  - Складывать, вычитать, перемножать (`+`, `-`, `*`);
  - Сдвигать влево / вправо (`<<`, `>>`);
  - Сравнивать (`==`, `>`, `<`, `>=`, `<=`, `!=`);
  - Работать с битами (`~`, `&=`, `|=`, `^=`);
  - Получать число старших нулевых бит (`countl_zero()`);
  - Быстро проверять на ноль, чётность, отрицательность (`is_zero()`, `is_even()`, `is_negative()`);
  - Приводить к `uint64_t` (`to_uint()`);
  - Приводить к `int64_t` (`to_int()`);
  - Получать массив отдельных цифр (`get_digits()`) Цифры хранятся в порядке Little Endian.

# <a id="DynNum" name="DynNum"><a href="#DynNum">4.2.</a></a> `DynNum`

`DynNum` хранит число в виде строки и позволяет производить операции с идеальной точностью. Он поможет вам решить пункт <a href="#stage5">2.5.</a> - перевод float в строку и обратно.

**Использовать его в других пунктах запрещено**. Работа со строками медленная, вы получите TL. Вы должны реализовать операции над float так, как они устроены в железе, без работы со строками.

Класс `DynNum` принимает один шаблонный параметр - тип цифры, с которой он будет работать. По умолчанию этот параметр задаёт десятичную систему счисления, и вам, скорее всего, не придётся его менять.

### <a id="DynNum-1" name="DynNum-1"><a href="#DynNum-1">4.2.1.</a></a> Создание экземпляра

- `DynNum()` - конструктор по умолчанию, создаёт нулевой `DynNum`;
 
- `DynNum(const char* number)` - создаёт `DynNum` из строки;
  
- `DynNum(const DynNum& copy)` - конструктор копирования;

- `DynNum(DynNum& move)` - конструктор перемещения;

- `DynNum(bool sign, int dot_index, std::deque<Digit> digits)` - создает `DynNum` из заданного знака, индекса точки и вектора цифр. Скорее всего, не понадобится для решения.

### <a id="DynNum-2" name="DynNum-2"><a href="#DynNum-2">4.2.2.</a></a> Использование

- Операции, которые можно производить с `DynNum`:
  - Складывать, вычитать, перемножать (`+`, `-`, `*`);
  - Сравнивать (`==`, `>`, `<`, `>=`, `<=`, `!=`);
  - Приводить к строке (`to_string()`);
  - Возводить в неотрицательную степень (`binpow(int power)`).

# <a id="links" name="links"><a href="#links">5.</a></a> Полезные ссылки:
  - [IEEE 754 - Википедия](https://en.wikipedia.org/wiki/IEEE_754)
  - [Визуализация работы float32](https://www.h-schmidt.net/FloatConverter/IEEE754.html)
  - [Денормализованные числа - Википедия](https://en.wikipedia.org/wiki/Subnormal_number)
  - [Слайды с семинара](https://github.com/JakMobius/courses/blob/main/mipt-os-basic-2024/sem02/sem02.pdf)
  - [Статья про точный перевод строки в Float](https://dl.acm.org/doi/pdf/10.1145/93548.93557?download=false) (не обязателен к использованию, можно использовать бинарный поиск)
